// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
    Handler ServerInterface
    ErrFn func(c fiber.Ctx, err error) error
}

type MiddlewareFunc fiber.Handler

{{range .}}{{$opid := .OperationId}}

// {{$opid}} operation middleware
func (siw *ServerInterfaceWrapper) {{$opid}}(c fiber.Ctx) error {

  {{if or .RequiresParamObject (gt (len .PathParams) 0) }}
  var err error
  {{end}}

  {{range .PathParams}}// ------------- Path parameter "{{.ParamName}}" -------------
  var {{$varName := .GoVariableName}}{{$varName}} {{.TypeDef}}

  {{if .IsPassThrough}}
  {{$varName}} = c.Query("{{.ParamName}}")
  {{end}}
  {{if .IsJson}}
  err = json.Unmarshal([]byte(c.Query("{{.ParamName}}")), &{{$varName}})
  if err != nil {
    return siw.ErrFn(c, err)
    // return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Error unmarshaling parameter '{{.ParamName}}' as JSON: %w", err).Error())
  }
  {{end}}
  {{if .IsStyled}}
  err = runtime.BindStyledParameterWithOptions("{{.Style}}", "{{.ParamName}}", c.Params("{{.ParamName}}"), &{{$varName}}, runtime.BindStyledParameterOptions{Explode: {{.Explode}}, Required: {{.Required}}})
  if err != nil {
    return siw.ErrFn(c, err)
    // return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter {{.ParamName}}: %w", err).Error())
  }
  {{end}}

  {{end}}

{{range .SecurityDefinitions}}
  {{if or (eq .Scheme "bearer") (eq .Scheme "basic")}}
    header := c.GetReqHeaders()
    {{if not .Optional}}
    authHeader, ok := header["Authorization"]
    if !ok { 
        return siw.ErrFn(c, fmt.Errorf("Missing Authorization header"))
    }
    {{else}}
      authHeader, _ := header["Authorization"]
    {{end}}

    {{if not .Optional}}
    if len(authHeader) > 1 { 
        return siw.ErrFn(c, fmt.Errorf("Ambigous Authorization header"))
    }
    {{end}}

    {{if not .Optional}}
    token, ok := strings.CutPrefix(authHeader[len(authHeader)-1], "{{.Scheme | title}} ")
    if !ok { 
        return siw.ErrFn(c, fmt.Errorf("Invalid Authorization scheme"))
    }
    {{else}}
    token, _ := strings.CutPrefix(authHeader[len(authHeader)-1], "{{.Scheme | title}} ")
    {{end}}

    c.Locals("{{.ProviderName}}", token)
  {{else}}
    c.Locals({{.ProviderName | ucFirst}}Scopes, {{toStringArray .Scopes}})
  {{end}}
{{end}}

  {{if .RequiresParamObject}}
    // Parameter object where we will unmarshal all parameters from the context
    var params {{.OperationId}}Params

    {{if .QueryParams}}
    var query url.Values
    query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
    if err != nil {
      return siw.ErrFn(c, err)
      // return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
    }
    {{end}}

    {{range $paramIdx, $param := .QueryParams}}
      {{- if (or (or .Required .IsPassThrough) (or .IsJson .IsStyled)) -}}
        // ------------- {{if .Required}}Required{{else}}Optional{{end}} query parameter "{{.ParamName}}" -------------
      {{ end }}
      {{ if (or (or .Required .IsPassThrough) .IsJson) }}
        if paramValue := c.Query("{{.ParamName}}"); paramValue != "" {

        {{if .IsPassThrough}}
          params.{{.GoName}} = {{if .HasOptionalPointer}}&{{end}}paramValue
        {{end}}

        {{if .IsJson}}
          var value {{.TypeDef}}
          err = json.Unmarshal([]byte(paramValue), &value)
          if err != nil {
            return siw.ErrFn(c, err)
          }

          params.{{.GoName}} = {{if .HasOptionalPointer}}&{{end}}value
        {{end}}
        }{{if .Required}} else {
            err = fmt.Errorf("Query argument {{.ParamName}} is required, but not found")
            return siw.ErrFn(c, err)
        }{{end}}
      {{end}}
      {{if .IsStyled}}
      err = runtime.BindQueryParameter("{{.Style}}", {{.Explode}}, {{.Required}}, "{{.ParamName}}", query, &params.{{.GoName}})
      if err != nil {
        return siw.ErrFn(c, err)
      }
      {{end}}
  {{end}}

    {{if .HeaderParams}}
      headers := c.GetReqHeaders()

      {{range .HeaderParams}}// ------------- {{if .Required}}Required{{else}}Optional{{end}} header parameter "{{.ParamName}}" -------------
        if value, found := headers[http.CanonicalHeaderKey("{{.ParamName}}")]; found {
          var {{.GoName}} {{.TypeDef}}

        {{if .IsPassThrough}}
          params.{{.GoName}} = {{if .HasOptionalPointer}}&{{end}}value
        {{end}}

        {{if .IsJson}}
          err = json.Unmarshal([]byte(value), &{{.GoName}})
          if err != nil {
            return siw.ErrFn(c, err)
          }
        {{end}}

        {{if .IsStyled}}
          err = runtime.BindStyledParameterWithOptions("{{.Style}}", "{{.ParamName}}", value[len(value)-1], &{{.GoName}}, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: {{.Explode}}, Required: {{.Required}}})
          if err != nil {
            return siw.ErrFn(c, err)
          }
        {{end}}

          params.{{.GoName}} = {{if .HasOptionalPointer}}&{{end}}{{.GoName}}

        } {{if .Required}}else {
            err = fmt.Errorf("Header parameter {{.ParamName}} is required, but not found: %w", err)
            return siw.ErrFn(c, err)
        }{{end}}

      {{end}}
    {{end}}

    {{range .CookieParams}}
      var cookie string

      if cookie = c.Cookies("{{.ParamName}}"); cookie == "" {

      {{- if .IsPassThrough}}
        params.{{.GoName}} = {{if .HasOptionalPointer}}}&{{end}}cookie
      {{end}}

      {{- if .IsJson}}
        var value {{.TypeDef}}
        var decoded string
        decoded, err := url.QueryUnescape(cookie)
        if err != nil {
          return siw.ErrFn(c, err)
        }

        err = json.Unmarshal([]byte(decoded), &value)
        if err != nil {
          return siw.ErrFn(c, err)
        }

        params.{{.GoName}} = {{if .HasOptionalPointer}}&{{end}}value
      {{end}}

      {{- if .IsStyled}}
        var value {{.TypeDef}}
        err = runtime.BindStyledParameterWithOptions("simple", "{{.ParamName}}", cookie, &value, runtime.BindStyledParameterOptions{Explode: {{.Explode}}, Required: {{.Required}}})
        if err != nil {
          return siw.ErrFn(c, err)
        }
        params.{{.GoName}} = {{if .HasOptionalPointer}}&{{end}}value
      {{end}}

      }

      {{- if .Required}} else {
        err = fmt.Errorf("Query argument {{.ParamName}} is required, but not found")
        return siw.ErrFn(c, err)
      }
      {{- end}}
    {{end}}
  {{end}}

  return siw.Handler.{{.OperationId}}(c{{genParamNames .PathParams}}{{if .RequiresParamObject}}, params{{end}})
}
{{end}}
